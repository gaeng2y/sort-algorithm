# 정렬 알고리즘

Created: November 21, 2022 6:36 PM

# 빅오 표기법과 복잡도

### 시간 복잡도

알고리즘의 수행시간을 의미하는 지표

### 공간 복잡도

알고리즘의 메모리 사용량을 의미(횬다이에 와서는 제한적인 상황이 아니라면 크게 의미없다)

## Big **Ω 표기법**

어떤 알고리즘의 최선의 경우에 대한 표기법

## Big O 표기법

어떤 알고리즘의 최악의 경우에 대한 표기법

![bigo]([https://images.velog.io/images/zxcvbnm5288/post/2aeb4f90-952e-416d-b5ac-2d51eb0b0e97/normalbigo.jpg](https://images.velog.io/images/zxcvbnm5288/post/2aeb4f90-952e-416d-b5ac-2d51eb0b0e97/normalbigo.jpg))

# 정렬 알고리즘

예를 들어 1부터 10까지 적혀있는 공이 불규칙하게 들어있는 주머니에서 공을 하나씩 꺼내어 작은 수부터 큰 수의 순서로 공을 나열한다고 생각해보자. 보통 이런 경우 사람도 어렵지 않게 쓱쓱 정렬해낸다. 하지만 컴퓨터가 주로 다루는 데이터는 **`10,000`**개일수도 **`10,000,000`**개일수도 있다. 그리고 데이터베이스 같은 경우는 이론상 무한 개의 데이터를 다룰 수 있어야 한다.

이때 데이터가 정렬되어 있지 않다면 순차적으로 하나씩 데이터를 봐가면서 탐색해야하지만, 데이터가 이미 정렬되어있다면 위에서 예시로 들었던 **`이진탐색(Binary Search)`**와 같은 강력한 알고리즘을 사용할 수도 있다.

### 종류

1. O(n^2)
    - 버블 정렬
    - 선택 정렬
    - 삽입 정렬
2. O(nlogn)
    - 병합 정렬
    - 힙 정렬
    - 퀵 정렬
    - 트리 정렬
3. 그외
    - 기수 정렬
    - 카운팅 정렬

## 버블 정렬(Bubble Sort)

1번째와 2번째 원소를 비교 후 정렬, 2번째와 3번째, … n - 1 번째와 n번째를 정렬한 뒤 다시 처음으로 돌아가 이번에는 n-2번째와 n-1번째까지 … 해서 최대 n(n - 1) / 2 번 정렬한다

> 한번 돌 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여 거품정렬이다
> 

## 선택 정렬(Select Sort)

버블 정렬이 비교하고 바로 바꿔 넣는 걸 반복한다면 선택 정렬은 일단 1번째부터 끝까지 훑어서 가장 작은게 1번째, 2번째 부터 끝까지 훑어서 가장 작은게 2번째… 해서 (n - 1)번 반복한다.

n(n - 1) / 2에 비례하는 시간이 걸린다. 또한, 버블 정렬보다 두배 정도 빠르다.

## 병합 정렬(Merge Sort)

원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개고 쪼개서 자른 순서의 역순으로 크기를 비교해 병합해 나간다. 병합된 부분 안은 이미 정렬되어 있으므로 전부 비교하지 않아도 제자리를 찾을 수 있다. 대표적인 분할 정복 알고리즘이다.

성능은 아래의 퀵 정렬보다 전반적으로 뒤떨어지고, 데이터 크기만한 메모리가 더 필요하지만 최대 장점은 데이터의 상태에 별 영향을 받지 않는다는 점이다.

힙이나 퀵의 경우에는 배열 `A[25]=100`, `A[33]=100`인 정수형 배열을 정렬한다고 할 때, 33번째에 있던 100이 25번째에 있던 100보다 앞으로 오는 경우가 생길 수 있다. 그에 반해서 병합정렬은 이런 일이 발생하지 않는다. 기본적으로 병합정렬은 쪼갠 후 두 값을 비교할 때 값이 같으면 정렬하지 않게 설계되기 때문이다. 그게 뭐가 중요하냐고 할 수 있지만, 실제 상황에서 여러 기준으로 정렬했을 때 동일 값에 대해선 기존 기준의 정렬순서가 유지되어야 한다.

## 힙 정렬(Heap Sort)

힙이 뭔지에 대해서 알고 있어야 이해가 가능하다([힙이 무엇인가?](https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)))

1. 원소들을 모두 힙에 삽입한다.
2. 힙의 루트에 있는 값은 남은 수들 중에서 최솟값을 가지므로 루트를 출력하고 힙에서 제거한다.
3. 힙이 빌 때까지 2의 과정을 반복한다.

## 퀵 정렬(Quick Sort)

이름에서 알 수 있듯이 평균적인 상황에서 최고의 성능을 나타낸다. 컴퓨터로 가장 많이 구현된 정렬 알고리즘 중 하나이다. 언어에서 제공하는 정렬 함수에서 퀵 정렬 혹은 퀵 정렬의 변형 알고리즘을 사용한다.

방식은 적절한 원소 하나를 기준(pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈 뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬한다. 이렇게 피벗을 잡고 이보다 작은 원소들을 왼쪽으로, 보다 큰 원소들을 오른쪽으로 나누는 걸 partition step이라 한다. 

퀵 정렬에서도 이 partition step을 어떻게 하느냐에 따라 바리에이션이 매우 많으며, 성능 차이도 날 수 있다.

![quick]([https://w.namu.la/s/6f0ffa1ef1518eede0a12ff1bcc5bef3c3fab7048a57c85f6b4d039ae9630026b385eaad9369fbac780749d5c8ea032ce4a70e663b04bc0cc576929f24af5c7b89d1924015b709c5b3bcba25be5c7b2b155896498b7abb8b0774700c70715034b42e000818dc4bc2e88d9ac2f51a7568](https://w.namu.la/s/6f0ffa1ef1518eede0a12ff1bcc5bef3c3fab7048a57c85f6b4d039ae9630026b385eaad9369fbac780749d5c8ea032ce4a70e663b04bc0cc576929f24af5c7b89d1924015b709c5b3bcba25be5c7b2b155896498b7abb8b0774700c70715034b42e000818dc4bc2e88d9ac2f51a7568))

## 기수 정렬(Radix Sort)

O(n)

위에 나온 알고리즘은 모두 데이터끼리의 직접적인 비교를 이용하는데, 이렇게 데이터끼리 직접적인 비교를 하여 정렬할 경우 시간복잡도는 `O(nlogn)`보다 작아질 수 없다. 이 기수 정렬은 자릿수가 있는 데이터(정수, 문자열 등)에서만 수행이 가능하며, **데이터끼리의 직접적인 비교 없이** 정렬을 수행한다. 비교를 이용한 정렬이 아니기 때문에 k가 상수일 경우 시간복잡도가 `O(n)`으로 **퀵정렬보다 빠른 시간복잡도**가 나오는 것이 가능하다.

다만 이 알고리즘은 자릿수가 적은 4바이트 정수 등에서나 제대로 된 성능을 발휘할 수 있으며, 자릿수가 무제한에 가까운 문자열 정렬 등에 사용할 경우 오히려 퀵정렬보다 느릴 수 있고, 부동 소수점의 경우는 부호여부, 지수부, 가수부에 대해 각각 기수정렬을 실행해야 한다.

기수 정렬의 방식은 대충 이렇다. 데이터가 x진법이라고 가정하자. 0번부터 x-1번까지의 리스트를 만들어 놓고, 각 데이터를 순서대로 현재 자릿수의 숫자가 가리키는 리스트에 밀어넣고, 리스트를 0번부터 x-1번까지 순서대로 이어붙인다. 이 과정을 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복하면 정렬이 끝나게 된다.

## 카운팅 정렬(Counting Sort)

`O(n + k)`

카운팅 정렬은 가장 큰 데이터에 따라 효율이 좌지우지된다. 쉽게 설명하자면 특정 데이터의 개수(1이 두 개 있다면 2)를 데이터의 값에 대응하는 위치에 저장한 뒤, 자신의 위치에서 앞에 있던 값을 모두 더한 배열을 만든 뒤, 거기서 데이터가 들어가야 할 위치를 찾아내는 정렬 알고리즘이다.

1. 자료를 탐색해서 그 최댓값을 구한다.
    - `input = [1, 5, 4, 6, 3, 7, 8, 9, 10, 2]`
    - 최댓값: `k = 10`
2. `k+1`만큼의 크기로 모든 자료가 0으로 초기화된 배열을 생성한다.
    - 배열 `counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` (11개)
3. `input`의 모든 원소 `n`에 대하여 `counts`의 `n`에 대응하는 곳에 +1을 해준다.
    - `counts = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`
    - 이때 `counts[n]`은 배열 `input`에 n이 몇 개 있는지를 의미한다.
4. `counts[i] += counts[i-1]`의 [점화식](https://namu.wiki/w/%EC%A0%90%ED%99%94%EC%8B%9D)을 1부터 k의 위치까지 행한다.
    - `counts = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
    - 이때 `counts[n]`은 배열 `input`에 n 이하의 원소가 몇 개 있는지를 의미한다.
5. 길이가 `counts[k]`인 배열을 하나 더 생성한다.
    - 배열 `ans = [N, N, N, N, N, N, N, N, N, N]` (10개, N은 [Null](https://namu.wiki/w/Null#s-2))
6. `counts`의 `input[0]`에 대응하는 곳의 원소를 찾아서 t로 놓는다. 이제 `ans`의 `t-1`에 대응하는 곳에 `input[0]`을 저장하고, `counts`의 `input[0]`에 대응하는 곳의 값은 -1 해준다.
    - 1이 주어짐
    - `counts[1] = 1`
    - 대응하는 값인 1-1=0의 위치에 1을 삽입
    - `ans = [1, N, N, N, N, N, N, N, N, N]`
    - `counts`는 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`에서 `[0, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10]`로 바뀜
7. 6의 과정을 남아 있는 자료에 대하여 반복한다.
    - 5가 주어짐
    - `counts[5] = 5`
    - 대응하는 값인 5-1=4의 위치에 5를 삽입
    - `ans = [1, N, N, N, 5, N, N, N, N, N]`
    - `counts`는 `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`에서 `[0, 0, 2, 3, 4, 4, 6, 7, 8, 9, 10]`로 바뀜
    - ...
8. 이런 식으로 n개의 자료를 모두 조사하면 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`순서로 정렬이 된다.
